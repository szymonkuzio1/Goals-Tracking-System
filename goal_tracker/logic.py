"""
Modu≈Ç logiki biznesowej systemu ≈õledzenia cel√≥w
Zawiera g≈Ç√≥wne algorytmy zarzƒÖdzania celami i analizƒô danych
"""
import json
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional, Tuple, Set

from .models.goal import Goal, PersonalGoal, BusinessGoal
from .utils.validators import validate_goal_data, validate_progress_value

# Zmienne globalne konfiguracyjne
MAX_GOALS = 50
MIN_PROGRESS_INTERVAL_HOURS = 1
DEFAULT_ANALYSIS_PERIOD_DAYS = 30
ACHIEVEMENT_THRESHOLDS = {
    'beginner': 25.0,
    'intermediate': 50.0,
    'advanced': 75.0,
    'expert': 100.0
}


class GoalManager:
    """
    G≈Ç√≥wna klasa zarzƒÖdzania celami i postƒôpami
    """

    def __init__(self, data_manager=None):
        self._goals_storage = {}  # prywatny s≈Çownik: {user_id: [Goal]}
        self._data_manager = data_manager
        self._last_backup_time = None  # czas ostatniej kopii zapasowej

    def _validate_user_goal_limit(self, username: str) -> bool:
        """Prywatna metoda sprawdzania limitu cel√≥w"""
        user_goals = self._goals_storage.get(username, [])
        return len(user_goals) < MAX_GOALS

    def add_goal(self, username: str, goal: Goal) -> bool:
        """Dodanie nowego celu do systemu"""

        try:
            assert isinstance(goal, Goal), "Obiekt musi byƒá instancjƒÖ klasy Goal"
            assert len(username.strip()) > 0, "Nazwa u≈ºytkownika nie mo≈ºe byƒá pusta"

            # Sprawdzenie limitu cel√≥w
            if not self._validate_user_goal_limit(username):
                raise ValueError(f"Przekroczono limit {MAX_GOALS} cel√≥w")

            # Walidacja danych celu
            goal_data = goal.to_dict()
            is_valid, errors = validate_goal_data(goal_data)

            if not is_valid:
                raise ValueError(f"Nieprawid≈Çowe dane celu: {', '.join(errors)}")

            # Dodanie celu do storage
            if username not in self._goals_storage:
                self._goals_storage[username] = []

            self._goals_storage[username].append(goal)

            # Zapis do pliku je≈õli data_manager dostƒôpny
            if self._data_manager:
                try:
                    goals_data = [g.to_dict() for g in self._goals_storage[username]]
                    self._data_manager.save_goals_data(goals_data, username)
                except Exception as e:
                    print(f"Ostrze≈ºenie: Nie uda≈Ço siƒô zapisaƒá do pliku: {e}")

            print(f"‚úÖ Cel '{goal.title}' dodany pomy≈õlnie dla u≈ºytkownika {username}")
            return True

        except (AssertionError, ValueError) as e:
            print(f"‚ùå B≈ÇƒÖd dodawania celu: {e}")
            return False
        except Exception as e:
            print(f"‚ùå Nieoczekiwany b≈ÇƒÖd: {e}")
            return False

    def get_user_goals(self, username: str) -> List[Goal]:
        """Pobranie wszystkich cel√≥w u≈ºytkownika"""
        try:
            return self._goals_storage.get(username, []).copy()
        except Exception as e:
            print(f"B≈ÇƒÖd pobierania cel√≥w: {e}")
            return []

    def get_user_goals_count(self, username: str) -> int:
        """Liczba cel√≥w u≈ºytkownika"""
        return len(self._goals_storage.get(username, []))

    def update_goal_progress(self, username: str, goal_id: str, new_value: float, note: str = "") -> bool:
        """Aktualizacja postƒôpu konkretnego celu"""

        def _find_goal_by_id(goals: List[Goal], target_id: str) -> Optional[Goal]:
            """Wewnƒôtrzna funkcja wyszukiwania celu po ID"""
            for goal in goals:
                if goal.id == target_id:
                    return goal
            return None

        def _check_progress_interval(goal: Goal) -> bool:
            """Wewnƒôtrzna funkcja sprawdzania interwa≈Çu aktualizacji"""
            if not hasattr(goal, '_last_update') or goal._last_update is None:
                return True

            time_diff = datetime.now() - goal._last_update
            return time_diff.total_seconds() / 3600 >= MIN_PROGRESS_INTERVAL_HOURS

        try:
            user_goals = self._goals_storage.get(username, [])
            goal = _find_goal_by_id(user_goals, goal_id)

            if not goal:
                raise ValueError(f"Nie znaleziono celu o ID: {goal_id}")

            # Sprawdzenie interwa≈Çu aktualizacji
            if not _check_progress_interval(goal):
                print(f"‚ö†Ô∏è Mo≈ºesz aktualizowaƒá postƒôp maksymalnie co {MIN_PROGRESS_INTERVAL_HOURS} godzin(y)")
                return False

            # Walidacja nowej warto≈õci
            is_valid, message = validate_progress_value(new_value, goal.target_value)
            if not is_valid:
                raise ValueError(message)

            # Aktualizacja postƒôpu
            old_value = goal.current_value
            if goal.update_progress(new_value):

                # Oznaczenie czasu ostatniej aktualizacji
                goal._last_update = datetime.now()

                print(f"‚úÖ Postƒôp zaktualizowany: {old_value} ‚Üí {new_value}")

                # Sprawdzenie kamieni milowych dla cel√≥w biznesowych
                if isinstance(goal, BusinessGoal):
                    achieved_milestones = goal.check_milestones()
                    for milestone in achieved_milestones:
                        print(f"üéâ OsiƒÖgniƒôto kamie≈Ñ milowy: {milestone}")

                return True
            else:
                return False

        except (ValueError, AssertionError) as e:
            print(f"‚ùå B≈ÇƒÖd aktualizacji postƒôpu: {e}")
            return False
        except Exception as e:
            print(f"‚ùå Nieoczekiwany b≈ÇƒÖd aktualizacji: {e}")
            return False

    def remove_goal(self, username: str, goal_id: str) -> bool:
        """Usuniƒôcie celu"""
        try:
            user_goals = self._goals_storage.get(username, [])

            # Filtrowanie - usuniƒôcie celu o podanym ID
            updated_goals = list(filter(lambda g: g.id != goal_id, user_goals))

            if len(updated_goals) == len(user_goals):
                print(f"‚ùå Nie znaleziono celu o ID: {goal_id}")
                return False

            self._goals_storage[username] = updated_goals

            print(f"‚úÖ Cel usuniƒôty pomy≈õlnie")
            return True

        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd usuwania celu: {e}")
            return False

    def load_goals_from_data_manager(self, username: str = "default") -> bool:
        """
        Za≈Çadowanie cel√≥w z DataManager do GoalManager
        """
        try:
            if not self._data_manager:
                print("‚ùå Brak dostƒôpnego DataManager")
                return False

            # Za≈Çadowanie danych cel√≥w z pliku
            goals_data = self._data_manager.load_goals_data(username)

            if not goals_data:
                print("‚ÑπÔ∏è Brak cel√≥w do za≈Çadowania")
                return True

            # Konwersja s≈Çownik√≥w na obiekty Goal
            loaded_goals = []
            for goal_dict in goals_data:
                try:
                    # Okre≈õlenie typu celu na podstawie goal_type
                    goal_type = goal_dict.get('goal_type', 'Og√≥lny')

                    if goal_type == 'Osobisty':
                        goal = PersonalGoal(
                            goal_dict['title'],
                            goal_dict['description'],
                            goal_dict['target_value']
                        )
                    elif goal_type == 'Biznesowy':
                        goal = BusinessGoal(
                            goal_dict['title'],
                            goal_dict['description'],
                            goal_dict['target_value']
                        )
                    else:
                        goal = Goal(
                            goal_dict['title'],
                            goal_dict['description'],
                            goal_dict['target_value']
                        )

                    # Ustawienie dodatkowe w≈Ça≈õciwo≈õci
                    goal.id = goal_dict.get('id', goal.id)
                    goal.current_value = goal_dict.get('current_value', 0.0)
                    goal.status = goal_dict.get('status', 'aktywny')

                    # Ustawienie daty
                    if 'created_date' in goal_dict and goal_dict['created_date']:
                        if isinstance(goal_dict['created_date'], str):
                            goal.created_date = datetime.fromisoformat(
                                goal_dict['created_date'].replace('Z', '+00:00')
                            )
                        else:
                            goal.created_date = goal_dict['created_date']

                    if 'deadline' in goal_dict and goal_dict['deadline']:
                        if isinstance(goal_dict['deadline'], str):
                            goal.deadline = datetime.fromisoformat(
                                goal_dict['deadline'].replace('Z', '+00:00')
                            )
                        else:
                            goal.deadline = goal_dict['deadline']

                    # Ustawienie historiƒô
                    goal._history = goal_dict.get('history', [])

                    loaded_goals.append(goal)

                except Exception as e:
                    print(f"‚ö†Ô∏è B≈ÇƒÖd ≈Çadowania celu '{goal_dict.get('title', 'Nieznany')}': {e}")
                    continue

            # Dodanie celu do storage
            if username not in self._goals_storage:
                self._goals_storage[username] = []

            self._goals_storage[username].extend(loaded_goals)

            print(f"‚úÖ Za≈Çadowano {len(loaded_goals)} cel√≥w do GoalManager")
            return True

        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd ≈Çadowania cel√≥w do GoalManager: {e}")
            return False

    def get_goals_by_type(self, username: str, goal_type: str) -> List[Goal]:
        """Pobranie cel√≥w wed≈Çug typu - u≈ºycie filter()"""
        try:
            user_goals = self._goals_storage.get(username, [])
            return list(filter(lambda g: g.get_goal_type().lower() == goal_type.lower(), user_goals))
        except Exception as e:
            print(f"B≈ÇƒÖd filtrowania wed≈Çug typu: {e}")
            return []

    def get_goals_by_status(self, username: str, status: str) -> List[Goal]:
        """Pobranie cel√≥w wed≈Çug statusu z filter()"""
        try:
            user_goals = self._goals_storage.get(username, [])
            return list(filter(lambda g: g.status.lower() == status.lower(), user_goals))
        except Exception as e:
            print(f"B≈ÇƒÖd filtrowania wed≈Çug statusu: {e}")
            return []

    def search_goals(self, username: str, search_term: str) -> List[Goal]:
        """Wyszukiwanie cel√≥w po nazwie/opisie z filter()"""

        def _matches_search_term(goal: Goal, term: str) -> bool:
            """Wewnƒôtrzna funkcja sprawdzania dopasowania"""
            term_lower = term.lower()
            return (term_lower in goal.title.lower() or
                    term_lower in goal.description.lower())

        try:
            user_goals = self._goals_storage.get(username, [])
            return list(filter(lambda g: _matches_search_term(g, search_term), user_goals))
        except Exception as e:
            print(f"B≈ÇƒÖd wyszukiwania cel√≥w: {e}")
            return []

    def backup_data(self) -> bool:
        """Tworzenie kopii zapasowej danych"""
        try:
            if not self._data_manager:
                print("‚ùå Brak dostƒôpnego managera danych")
                return False

            backup_data = {
                'goals_storage': {},
                'backup_timestamp': datetime.now().isoformat()
            }

            # Konwersja cel√≥w do formatu s≈Çownikowego
            for username, goals in self._goals_storage.items():
                backup_data['goals_storage'][username] = [goal.to_dict() for goal in goals]

            # Zapis kopii zapasowej
            backup_filename = f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            success = self._data_manager.save_backup(backup_data, backup_filename)

            if success:
                self._last_backup_time = datetime.now()
                print(f"‚úÖ Kopia zapasowa utworzona: {backup_filename}")
                return True
            else:
                print("‚ùå Nie uda≈Ço siƒô utworzyƒá kopii zapasowej")
                return False

        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd tworzenia kopii zapasowej: {e}")
            return False

